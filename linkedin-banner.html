<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spiral Works - LinkedIn Banner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.155.0/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #121212;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }
        
        #banner-container {
            width: 3168px;
            height: 792px;
            position: relative;
            background: #121212;
            overflow: hidden;
        }
        
        #banner-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
    </style>
</head>
<body>
    <div id="banner-container">
        <canvas id="banner-canvas"></canvas>
    </div>

    <script>
        // LinkedIn banner dimensions - High resolution
        const BANNER_WIDTH = 3168;
        const BANNER_HEIGHT = 792;
        
        const canvas = document.getElementById('banner-canvas');
        const scene = new THREE.Scene();
        
        // Theme colors for dark LinkedIn banner
        const themeColors = {
            primary: '#a64dff',
            secondary: '#3222c9',
            accent: '#a64dff'
        };
        
        const parameters = {
            nodeCount: 800,
            flowParticleCount: 2000,
            nodeSize: 0.006,
            flowParticleSize: 0.003,
            networkRadius: 0.8,
            connectionOpacity: 0.18,
            flowSpeed: 0.12,
            primaryColor: themeColors.primary,
            secondaryColor: themeColors.secondary,
            accentColor: themeColors.accent
        };
        
        let networkNodes = [];
        let connections = [];
        let flowParticles = [];
        let objectPool = {
            nodes: null,
            connections: null,
            flowParticles: null,
            nodeGeometry: null,
            nodeMaterial: null,
            connectionGeometry: null,
            connectionMaterial: null,
            flowGeometry: null,
            flowMaterial: null
        };
        
        const generateNetwork = () => {
            // Generate neural network nodes
            networkNodes = [];
            
            const structures = [
                { count: Math.floor(parameters.nodeCount * 0.4), type: 'core', radius: 0.3 },
                { count: Math.floor(parameters.nodeCount * 0.3), type: 'dendrites', radius: 0.6 },
                { count: Math.floor(parameters.nodeCount * 0.3), type: 'web', radius: 1.0 }
            ];
            
            structures.forEach(struct => {
                for (let i = 0; i < struct.count; i++) {
                    let x, y, z, nodeType;
                    
                    if (struct.type === 'core') {
                        const goldenAngle = Math.PI * (3.0 - Math.sqrt(5.0));
                        const normalizedIndex = i / struct.count;
                        const radius = Math.pow(normalizedIndex, 0.7) * parameters.networkRadius * struct.radius;
                        const phi = i * goldenAngle;
                        const theta = Math.acos(1 - 2 * normalizedIndex);
                        
                        x = radius * Math.cos(phi) * Math.sin(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(theta);
                        nodeType = 'core';
                        
                    } else if (struct.type === 'dendrites') {
                        const branchCount = 8;
                        const branchIndex = i % branchCount;
                        const nodeInBranch = Math.floor(i / branchCount);
                        const branchProgress = nodeInBranch / Math.floor(struct.count / branchCount);
                        
                        const branchAngle = (branchIndex / branchCount) * Math.PI * 2;
                        const branchRadius = branchProgress * parameters.networkRadius * struct.radius;
                        
                        const subBranchAngle = branchAngle + Math.sin(branchProgress * 8) * 0.5;
                        const heightVariation = Math.sin(branchProgress * 6) * 0.3;
                        
                        x = branchRadius * Math.cos(subBranchAngle);
                        y = branchRadius * Math.sin(subBranchAngle) + heightVariation;
                        z = (Math.random() - 0.5) * branchRadius * 0.6;
                        nodeType = 'dendrite';
                        
                    } else {
                        const radius = (Math.random() * 0.4 + 0.6) * parameters.networkRadius * struct.radius;
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.acos(1 - 2 * Math.random());
                        
                        x = radius * Math.cos(phi) * Math.sin(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(theta);
                        nodeType = 'web';
                    }
                    
                    const noise = 0.05;
                    x += (Math.random() - 0.5) * noise;
                    y += (Math.random() - 0.5) * noise;
                    z += (Math.random() - 0.5) * noise;
                    
                    networkNodes.push({
                        position: new THREE.Vector3(x, y, z),
                        connections: [],
                        activity: Math.random(),
                        pulsePhase: Math.random() * Math.PI * 2,
                        nodeType: nodeType,
                        structureIndex: structures.indexOf(struct)
                    });
                }
            });
            
            // Create connections
            connections = [];
            for (let i = 0; i < networkNodes.length; i++) {
                const node1 = networkNodes[i];
                
                const distances = [];
                for (let j = 0; j < networkNodes.length; j++) {
                    if (i !== j) {
                        const distance = node1.position.distanceTo(networkNodes[j].position);
                        distances.push({ index: j, distance: distance, node: networkNodes[j] });
                    }
                }
                
                distances.sort((a, b) => a.distance - b.distance);
                
                let maxConnections;
                if (node1.nodeType === 'core') {
                    maxConnections = 20;
                } else if (node1.nodeType === 'dendrite') {
                    maxConnections = 15;
                } else {
                    maxConnections = 8;
                }
                
                for (let k = 0; k < Math.min(maxConnections, distances.length); k++) {
                    const neighbor = distances[k];
                    
                    if (Math.random() > 0.1 && neighbor.distance < parameters.networkRadius * 0.6) {
                        const alreadyConnected = connections.some(conn => 
                            (conn.from === i && conn.to === neighbor.index) ||
                            (conn.from === neighbor.index && conn.to === i)
                        );
                        
                        if (!alreadyConnected) {
                            connections.push({
                                from: i,
                                to: neighbor.index,
                                strength: Math.max(0.3, 1.0 - (neighbor.distance / parameters.networkRadius)),
                                layer: node1.layer
                            });
                            node1.connections.push(neighbor.index);
                            neighbor.node.connections.push(i);
                        }
                    }
                }
            }
            
            // Create nodes
            const nodePositions = new Float32Array(networkNodes.length * 3);
            const nodeColors = new Float32Array(networkNodes.length * 3);
            
            const primaryColorObj = new THREE.Color(parameters.primaryColor);
            const accentColorObj = new THREE.Color(parameters.accentColor);
            const secondaryColorObj = new THREE.Color(parameters.secondaryColor);
            
            networkNodes.forEach((node, index) => {
                nodePositions[index * 3] = node.position.x;
                nodePositions[index * 3 + 1] = node.position.y;
                nodePositions[index * 3 + 2] = node.position.z;
                
                let color = primaryColorObj.clone();
                if (node.nodeType === 'core') {
                    color.lerp(accentColorObj, 0.3);
                } else if (node.nodeType === 'dendrite') {
                    color.lerp(secondaryColorObj, 0.4);
                } else {
                    color.lerp(accentColorObj, Math.random() * 0.5);
                }
                
                nodeColors[index * 3] = color.r;
                nodeColors[index * 3 + 1] = color.g;
                nodeColors[index * 3 + 2] = color.b;
            });
            
            objectPool.nodeGeometry = new THREE.BufferGeometry();
            objectPool.nodeGeometry.setAttribute('position', new THREE.BufferAttribute(nodePositions, 3));
            objectPool.nodeGeometry.setAttribute('color', new THREE.BufferAttribute(nodeColors, 3));
            
            objectPool.nodeMaterial = new THREE.PointsMaterial({
                size: parameters.nodeSize * 2,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.4,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            objectPool.nodes = new THREE.Points(objectPool.nodeGeometry, objectPool.nodeMaterial);
            scene.add(objectPool.nodes);
            
            // Create connections
            const connectionGeometry = new THREE.BufferGeometry();
            const connectionPositions = new Float32Array(connections.length * 6);
            const connectionColors = new Float32Array(connections.length * 6);
            
            const connectionPrimaryColor = new THREE.Color(parameters.primaryColor);
            const connectionSecondaryColor = new THREE.Color(parameters.secondaryColor);
            
            for (let i = 0; i < connections.length; i++) {
                const connection = connections[i];
                const fromPos = networkNodes[connection.from].position;
                const toPos = networkNodes[connection.to].position;
                
                connectionPositions[i * 6] = fromPos.x;
                connectionPositions[i * 6 + 1] = fromPos.y;
                connectionPositions[i * 6 + 2] = fromPos.z;
                connectionPositions[i * 6 + 3] = toPos.x;
                connectionPositions[i * 6 + 4] = toPos.y;
                connectionPositions[i * 6 + 5] = toPos.z;
                
                const gradient = Math.random();
                const color = connectionPrimaryColor.clone().lerp(connectionSecondaryColor, gradient * 0.7);
                
                const brightness = 0.7 + Math.random() * 0.3;
                color.multiplyScalar(brightness);
                connectionColors[i * 6] = color.r;
                connectionColors[i * 6 + 1] = color.g;
                connectionColors[i * 6 + 2] = color.b;
                connectionColors[i * 6 + 3] = color.r;
                connectionColors[i * 6 + 4] = color.g;
                connectionColors[i * 6 + 5] = color.b;
            }
            
            connectionGeometry.setAttribute('position', new THREE.BufferAttribute(connectionPositions, 3));
            connectionGeometry.setAttribute('color', new THREE.BufferAttribute(connectionColors, 3));
            
            objectPool.connectionMaterial = new THREE.LineBasicMaterial({
                vertexColors: true,
                transparent: true,
                opacity: parameters.connectionOpacity * 1.5,
                blending: THREE.AdditiveBlending,
                linewidth: 1
            });
            
            objectPool.connections = new THREE.LineSegments(connectionGeometry, objectPool.connectionMaterial);
            scene.add(objectPool.connections);
            
            // Create flow particles
            objectPool.flowGeometry = new THREE.BufferGeometry();
            const flowPositions = new Float32Array(parameters.flowParticleCount * 3);
            const flowColors = new Float32Array(parameters.flowParticleCount * 3);
            
            flowParticles = [];
            
            for (let i = 0; i < parameters.flowParticleCount; i++) {
                if (connections.length === 0) break;
                
                const connection = connections[Math.floor(Math.random() * connections.length)];
                const progress = Math.random();
                const fromPos = networkNodes[connection.from].position;
                const toPos = networkNodes[connection.to].position;
                
                const currentPos = fromPos.clone().lerp(toPos, progress);
                
                flowPositions[i * 3] = currentPos.x;
                flowPositions[i * 3 + 1] = currentPos.y;
                flowPositions[i * 3 + 2] = currentPos.z;
                
                const color = new THREE.Color().lerpColors(
                    new THREE.Color(parameters.primaryColor),
                    new THREE.Color(parameters.secondaryColor),
                    Math.random()
                );
                
                flowColors[i * 3] = color.r;
                flowColors[i * 3 + 1] = color.g;
                flowColors[i * 3 + 2] = color.b;
                
                flowParticles.push({
                    connectionIndex: Math.floor(Math.random() * connections.length),
                    progress: progress,
                    speed: (Math.random() * 0.5 + 0.5) * parameters.flowSpeed,
                    life: 1.0
                });
            }
            
            objectPool.flowGeometry.setAttribute('position', new THREE.BufferAttribute(flowPositions, 3));
            objectPool.flowGeometry.setAttribute('color', new THREE.BufferAttribute(flowColors, 3));
            
            objectPool.flowMaterial = new THREE.PointsMaterial({
                size: parameters.flowParticleSize * 0.5,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.5,
                vertexColors: true,
                blending: THREE.AdditiveBlending
            });
            
            objectPool.flowParticles = new THREE.Points(objectPool.flowGeometry, objectPool.flowMaterial);
            scene.add(objectPool.flowParticles);
        };
        
        generateNetwork();
        
        // Camera and renderer setup
        const camera = new THREE.PerspectiveCamera(45, BANNER_WIDTH / BANNER_HEIGHT, 0.1, 100);
        camera.position.set(0, 0, 4);
        camera.lookAt(0, 0, 0);
        scene.add(camera);
        
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            alpha: true,
            antialias: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(BANNER_WIDTH, BANNER_HEIGHT);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 3));
        
        const clock = new THREE.Clock();
        
        const tick = () => {
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = clock.getDelta();
            
            // Slow camera rotation
            if (objectPool.nodes) {
                camera.position.x = Math.cos(elapsedTime * 0.08) * 3;
                camera.position.z = Math.sin(elapsedTime * 0.08) * 3;
                camera.lookAt(0, 0, 0);
            }
            
            // Update flow particles
            if (objectPool.flowParticles && connections.length > 0) {
                const positions = objectPool.flowGeometry.attributes.position.array;
                
                for (let i = 0; i < flowParticles.length; i++) {
                    const particle = flowParticles[i];
                    particle.progress += particle.speed * deltaTime;
                    
                    if (particle.progress > 1) {
                        particle.progress = 0;
                        particle.connectionIndex = Math.floor(Math.random() * connections.length);
                    }
                    
                    const connection = connections[particle.connectionIndex];
                    if (connection) {
                        const fromPos = networkNodes[connection.from].position;
                        const toPos = networkNodes[connection.to].position;
                        
                        const currentPos = fromPos.clone().lerp(toPos, particle.progress);
                        
                        positions[i * 3] = currentPos.x;
                        positions[i * 3 + 1] = currentPos.y;
                        positions[i * 3 + 2] = currentPos.z;
                    }
                }
                
                objectPool.flowGeometry.attributes.position.needsUpdate = true;
            }
            
            renderer.render(scene, camera);
            requestAnimationFrame(tick);
        };
        
        tick();
    </script>
</body>
</html>